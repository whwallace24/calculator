[{"/Users/williamwallace/Downloads/StarterFiles/week6/calculator/src/index.tsx":"1","/Users/williamwallace/Downloads/StarterFiles/week6/calculator/src/reportWebVitals.ts":"2","/Users/williamwallace/Downloads/StarterFiles/week6/calculator/src/Calculator.tsx":"3","/Users/williamwallace/devel/calculator/src/index.tsx":"4","/Users/williamwallace/devel/calculator/src/Calculator.tsx":"5","/Users/williamwallace/devel/calculator/src/CalculatorModel.ts":"6"},{"size":221,"mtime":1645650892492,"results":"7","hashOfConfig":"8"},{"size":425,"mtime":1645650572568,"results":"9","hashOfConfig":"8"},{"size":3071,"mtime":1645651331700,"results":"10","hashOfConfig":"8"},{"size":221,"mtime":1645650892492,"results":"11","hashOfConfig":"12"},{"size":3639,"mtime":1645723875278,"results":"13","hashOfConfig":"12"},{"size":11280,"mtime":1645723923530,"results":"14","hashOfConfig":"12"},{"filePath":"15","messages":"16","suppressedMessages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"xkfm8g",{"filePath":"19","messages":"20","suppressedMessages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"22","messages":"23","suppressedMessages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","suppressedMessages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1bncmbv",{"filePath":"28","messages":"29","suppressedMessages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"32","messages":"33","suppressedMessages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35"},"/Users/williamwallace/Downloads/StarterFiles/week6/calculator/src/index.tsx",[],[],["36","37"],"/Users/williamwallace/Downloads/StarterFiles/week6/calculator/src/reportWebVitals.ts",[],[],"/Users/williamwallace/Downloads/StarterFiles/week6/calculator/src/Calculator.tsx",[],[],"/Users/williamwallace/devel/calculator/src/index.tsx",[],[],"/Users/williamwallace/devel/calculator/src/Calculator.tsx",[],[],["38","39"],"/Users/williamwallace/devel/calculator/src/CalculatorModel.ts",["40"],[],"import { throws } from \"assert\";\r\n\r\nenum Operator {\r\n  Plus,\r\n  Minus,\r\n  Mult,\r\n  Div,\r\n  Sqrt\r\n}\r\n\r\n// abstract class for the state hierarchy. \r\ninterface ICalculatorState {  \r\n  digit(digit: string) : void;\r\n  decimalSeparator() : void;\r\n  binaryOperator(calc: CalculatorModel, operator: Operator) : void;\r\n  equals(calc: CalculatorModel) : void;\r\n  clear(calc: CalculatorModel) : void;\r\n  display() : string\r\n}\r\n\r\nclass EnteringFirstNumberState implements ICalculatorState {\r\n  constructor(private buffer: string){ }\r\n  digit(digit: string): void {\r\n    this.buffer = (this.buffer === '0' && digit !== '0') ? digit : this.buffer + digit; \r\n  }\r\n  decimalSeparator(): void {\r\n    if (this.buffer.indexOf('.') === -1){ // ignore if the number already has a decimal separator\r\n      this.buffer = this.buffer + '.';\r\n    } \r\n  }\r\n  binaryOperator(calc: CalculatorModel, operator: Operator): void {\r\n    if (operator === Operator.Sqrt) {\r\n      const number = parseFloat(this.buffer === '' ? '0' : this.buffer);\r\n      calc.changeState(new EnteringFirstNumberState((Math.sqrt(number)).toString()));\r\n    }\r\n    else {\r\n      calc.changeState(new EnteringSecondNumberState(this.buffer === '' ? '0' : this.buffer, '', operator));\r\n    }\r\n  }\r\n  equals(): void { /* pressing equals after entering one number has no effect */ }\r\n  clear(): void { this.buffer = '0'; }\r\n  display(){ return this.buffer !== '' ? this.buffer : '0'; }\r\n}\r\n\r\nclass EnteringSecondNumberState implements ICalculatorState {\r\n  constructor(private firstBuffer: string, private secondBuffer: string, \r\n              private firstOperator: Operator){ }\r\n  digit(digit: string): void {\r\n    this.secondBuffer = (this.secondBuffer === '0' && digit !== '0') ? digit : this.secondBuffer + digit; \r\n  }\r\n  decimalSeparator(): void {\r\n    if (this.secondBuffer.indexOf('.') === -1){ // ignore if the number already has a decimal separator\r\n      this.secondBuffer = this.secondBuffer + '.';\r\n    } \r\n  }\r\n  binaryOperator(calc: CalculatorModel, operator: Operator): void {\r\n    const firstNumber = parseFloat(this.firstBuffer === '' ? '0' : this.firstBuffer);\r\n    const secondNumber = parseFloat(this.secondBuffer === '' ? '0' : this.secondBuffer);\r\n    switch (operator){\r\n      case Operator.Plus:   // in case of + or - after having entered two numbers, apply the first operator and stay in this state\r\n      case Operator.Minus:  // (or go to ErrorState in case of division by zero)\r\n        if (this.firstOperator === Operator.Plus){\r\n          this.firstBuffer = (firstNumber + secondNumber).toString()\r\n        } else if (this.firstOperator === Operator.Minus){\r\n          this.firstBuffer = (firstNumber - secondNumber).toString()\r\n        } else if (this.firstOperator === Operator.Mult){\r\n          this.firstBuffer = (firstNumber * secondNumber).toString()\r\n        } else if (secondNumber !== 0){ // (this.firstOperator === Operator.Div){\r\n          this.firstBuffer = (firstNumber / secondNumber).toString()\r\n        } else {\r\n          calc.changeState(new ErrorState());\r\n        }\r\n        this.secondBuffer = '';\r\n        this.firstOperator = operator;\r\n        break;\r\n    case Operator.Div: // if we press * or / after having entered two numbers\r\n    case Operator.Mult:\r\n      if (this.firstOperator === Operator.Mult){ // If the first operator was *, apply it\r\n        this.firstBuffer = (firstNumber * secondNumber).toString();\r\n        this.secondBuffer = '';\r\n        this.firstOperator = operator;\r\n      } else if (this.firstOperator === Operator.Div){ // If the first operator was /, apply it \r\n        if (secondNumber === 0){ // check for div by zero\r\n          calc.changeState(new ErrorState());\r\n        } else {\r\n          this.firstBuffer = (firstNumber / secondNumber).toString();\r\n          this.secondBuffer = '';\r\n          this.firstOperator = operator;\r\n        }\r\n      } else { // If the first operator was + or -, transition to EnteringThirdNumberState\r\n        calc.changeState(new EnteringThirdNumberState(this.firstBuffer, this.secondBuffer, '', this.firstOperator, operator));\r\n      }\r\n    }\r\n  }\r\n  equals(calc: CalculatorModel): void {\r\n    const firstNumber = parseFloat(this.firstBuffer === '' ? '0' : this.firstBuffer);\r\n    const secondNumber = parseFloat(this.secondBuffer === '' ? '0' : this.secondBuffer);\r\n    if (this.firstOperator === Operator.Plus){\r\n      calc.changeState(new EnteringFirstNumberState((firstNumber + secondNumber).toString()));\r\n    } else if (this.firstOperator === Operator.Minus){\r\n      calc.changeState(new EnteringFirstNumberState((firstNumber - secondNumber).toString()));\r\n    } else if (this.firstOperator === Operator.Mult){\r\n      calc.changeState(new EnteringFirstNumberState((firstNumber * secondNumber).toString()));\r\n    } else if (secondNumber !== 0){  // this.firstOperator === Operator.Div\r\n      calc.changeState(new EnteringFirstNumberState((firstNumber / secondNumber).toString()));\r\n    } else {\r\n      calc.changeState(new ErrorState());\r\n    }\r\n  }\r\n  clear(calc: CalculatorModel): void {\r\n    calc.changeState(new EnteringFirstNumberState('0'));\r\n  }\r\n  display(){ \r\n    return (this.secondBuffer !== '') ? this.secondBuffer : this.firstBuffer; \r\n  }\r\n}\r\n\r\n// invariant: firstOperator is Plus or Minus and secondOperator is Div or Mul\r\nclass EnteringThirdNumberState implements ICalculatorState {\r\n  constructor(private firstBuffer: string, private secondBuffer: string, private thirdBuffer: string, \r\n              private firstOperator: Operator, private secondOperator: Operator){  }\r\n  digit(digit: string): void {\r\n    this.thirdBuffer = (this.thirdBuffer === '0' && digit !== '0') ? digit : this.thirdBuffer + digit; \r\n  }\r\n  decimalSeparator(): void { \r\n    if (this.thirdBuffer.indexOf('.') === -1){ // ignore if the number already has a decimal separator\r\n      this.thirdBuffer = this.thirdBuffer + '.';\r\n    }\r\n  }\r\n  binaryOperator(calc: CalculatorModel, operator: Operator): void { // evaluate the entire expression and transition to EnteringSecondNumberState \r\n                                             // (or ErrorState in case of division by zero)\r\n    const firstNumber = parseFloat(this.firstBuffer === '' ? '0' : this.firstBuffer);\r\n    const secondNumber = parseFloat(this.secondBuffer === '' ? '0' : this.secondBuffer);\r\n    const thirdNumber = parseFloat(this.thirdBuffer === '' ? '0' : this.thirdBuffer);\r\n    if (operator === Operator.Mult){\r\n      const result = secondNumber*thirdNumber;\r\n      this.secondBuffer = result.toString();\r\n      this.thirdBuffer = '';\r\n    } else if (this.secondOperator === Operator.Div){\r\n      if (thirdNumber === 0){\r\n        calc.changeState(new ErrorState());\r\n      } else {\r\n        const result = secondNumber/thirdNumber;\r\n        this.secondBuffer = result.toString();\r\n        this.thirdBuffer = '';\r\n      } \r\n    } else if (operator === Operator.Plus || operator === Operator.Minus) {  \r\n      if (this.secondOperator === Operator.Mult){\r\n        let result = secondNumber*thirdNumber;\r\n        if (this.firstOperator === Operator.Plus){\r\n          result = firstNumber + result;\r\n        } else { // (this.firstOperator === Operator.Minus)\r\n          result = firstNumber - result;\r\n        }\r\n        calc.changeState(new EnteringSecondNumberState(result.toString(), '', operator));\r\n      } else { // (this.secondOperator === Operator.Div)\r\n        if (thirdNumber !== 0) {\r\n          let result = secondNumber/thirdNumber;\r\n          if (this.firstOperator === Operator.Plus){\r\n            result = firstNumber + result;\r\n          } else { // (this.firstOperator === Operator.Minus)\r\n            result = firstNumber - result;\r\n          }\r\n          calc.changeState(new EnteringSecondNumberState(result.toString(), '', operator));\r\n        } else {\r\n          calc.changeState(new ErrorState());\r\n        }\r\n      } \r\n    }  \r\n  }\r\n  equals(calc: CalculatorModel): void { // evaluate the entire expression and transition to EnteringFirstNumberState\r\n                                        // (or ErrorState in case of division by zero)\r\n    const firstNumber = parseFloat(this.firstBuffer === '' ? '0' : this.firstBuffer);\r\n    const secondNumber = parseFloat(this.secondBuffer === '' ? '0' : this.secondBuffer);\r\n    const thirdNumber = parseFloat(this.thirdBuffer === '' ? '0' : this.thirdBuffer);\r\n    let result;\r\n    if (this.secondOperator === Operator.Mult){\r\n      result = secondNumber*thirdNumber;\r\n    } else { // (this.secondOperator === Operator.Div)\r\n      if (thirdNumber === 0){\r\n        calc.changeState(new ErrorState());\r\n        return;\r\n      } else {\r\n        result = secondNumber/thirdNumber;\r\n      }\r\n    }\r\n    if (this.firstOperator === Operator.Plus){\r\n      calc.changeState(new EnteringFirstNumberState((firstNumber+result).toString()));\r\n    } else { // (this.firstOperator === Operator.Minus)\r\n      calc.changeState(new EnteringFirstNumberState((firstNumber-result).toString()));\r\n    }\r\n  }\r\n  clear(calc: CalculatorModel): void {\r\n    calc.changeState(new EnteringFirstNumberState('0'));\r\n  }\r\n  display(){ \r\n    return (this.thirdBuffer !== '') ? this.thirdBuffer : (this.secondBuffer !== '' ? this.secondBuffer :'0'); \r\n  }\r\n}\r\n// in the ErrorState, pressing \"C\" will reset the calculator to its original state; other keys have no effect\r\nclass ErrorState implements ICalculatorState {\r\n  digit(digit: string): void { /* nothing */ }\r\n  decimalSeparator(): void { /* nothing */ }\r\n  binaryOperator(calc: CalculatorModel, operator: Operator): void { /* nothing */ }\r\n  equals(): void { /* nothing */ }\r\n  clear(calc: CalculatorModel): void { calc.changeState(new EnteringFirstNumberState('0')); }\r\n  display(){ return 'ERR'; }\r\n}  \r\n\r\nexport class CalculatorModel {\r\n  private state: ICalculatorState\r\n  constructor(){ this.state = new EnteringFirstNumberState(''); }\r\n  \r\n  changeState(state: ICalculatorState){ this.state = state; }\r\n  \r\n  // numeric buttons \r\n  public pressZero() : void { this.state.digit('0'); }\r\n  public pressOne() : void { this.state.digit('1'); }\r\n  public pressTwo() : void { this.state.digit('2'); }\r\n  public pressThree() : void { this.state.digit('3'); }\r\n  public pressFour() : void { this.state.digit('4'); }\r\n  public pressFive() : void { this.state.digit('5'); }\r\n  public pressSix() : void { this.state.digit('6'); }\r\n  public pressSeven() : void { this.state.digit('7'); }\r\n  public pressEight() : void { this.state.digit('8'); }\r\n  public pressNine() : void { this.state.digit('9'); }\r\n\r\n  // \".\", \"=\", and \"C\" buttons\r\n  public pressDot() : void { this.state.decimalSeparator(); }\r\n  public pressEquals() : void { this.state.equals(this); }  \r\n  public pressClear() : void { this.state.clear(this); } \r\n   \r\n  // operator buttons\r\n  public pressPlus() : void { this.state.binaryOperator(this, Operator.Plus); }\r\n  public pressMinus() : void { this.state.binaryOperator(this, Operator.Minus); }\r\n  public pressMult() : void { this.state.binaryOperator(this, Operator.Mult); }\r\n  public pressDiv() : void { this.state.binaryOperator(this, Operator.Div); }\r\n  public pressSqrt() : void { this.state.binaryOperator(this, Operator.Sqrt); }\r\n  \r\n  // returns the contents of the calculator's display\r\n  public display() : string { return this.state.display(); }\r\n}",{"ruleId":"41","replacedBy":"42"},{"ruleId":"43","replacedBy":"44"},{"ruleId":"41","replacedBy":"45"},{"ruleId":"43","replacedBy":"46"},{"ruleId":"47","severity":1,"message":"48","line":1,"column":10,"nodeType":"49","messageId":"50","endLine":1,"endColumn":16},"no-native-reassign",["51"],"no-negated-in-lhs",["52"],["51"],["52"],"@typescript-eslint/no-unused-vars","'throws' is defined but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]